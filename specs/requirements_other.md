
# 需求规格说明书: 缓存、性能与一致性检查

版本: 2.2
状态: 已批准

1. 概述
为了显著提升应用在处理大规模数据集时的响应速度和用户体验，本项目将引入一套分层的、智能化的缓存机制。该机制包含一个以SQLite为基础的“持久化数据缓存”和一个更高性能的、驻留于内存中的“内存缓存”。同时，本次迭代还将新增一个独立的、包含两种子模式的“关联键一致性检查”功能。

2. 核心术语
- 持久化数据缓存 (Persistent Data Cache): 指将Excel/CSV中的原始数据经过预处理后，存储在本地磁盘的SQLite数据库中。此缓存旨在避免对同一文件进行重复的、耗时的IO和解析操作，其生命周期可跨越应用重启。
- 内存缓存 (In-memory Cache): 指在一次应用会话中，将验证所需的数据长时驻留在内存中的数据结构（如哈希表）。它的目的是在多次验证之间，完全避免对磁盘（无论是原始文件还是SQLite文件）的重复读取。
- 会话级数据管理 (Session-level Data Management): 指持久化数据缓存和内存缓存的生命周期都与用户在UI上选择的文件相关联。
- 持久化缓存有效性 (Persistent Cache Validity): 用于判断持久化数据缓存是否仍然代表源文件的最新状态。

3. 非功能性需求
- 3.1 性能 (Performance):
  - 3.1.1 首次加载: 首次选择一个20万行文件时，应用需要进行预处理并构建持久化数据缓存，此过程应有明确的UI反馈。
  - 3.1.2 二次加载 (跨应用会话): 当再次启动应用并使用（未修改过的）同一个文件进行验证时，核心验证过程应从持久化数据缓存中读取数据，其耗时应从数十秒级显著降低到5秒以内。
  - 3.1.3 (新增) 极致复用 (单次应用会话内): 在一次应用会话中，如果一个文件的持久化缓存是有效的，它应该被加载到内存缓存中并持续驻留。当用户执行多次验证（例如，仅修改规则或比对文件）时，系统应直接使用此内存缓存，实现近乎瞬时的验证响应。
  - 3.1.4 (新增) 可观测性: 系统应提供监控缓存性能的手段。在设计阶段需考虑记录关键指标，如：持久化缓存的命中率、文件预处理和缓存加载的耗时等。
- 3.2 健壮性 (Robustness):
  - 3.2.1 持久化缓存一致性: 必须确保持久化数据缓存与数据源的一致性。当源文件被修改后，必须强制刷新持久化缓存。
  - 3.2.2 持久化缓存异常处理: 应用必须能优雅处理与持久化缓存相关的异常（如SQLite连接失败、磁盘空间不足等）。
  - 3.2.3 (新增) 缓存健壮性: 系统必须能够检测并处理持久化缓存文件损坏（如SQLite文件损坏、Schema不匹配）或数据格式不兼容的情况。当检测到此类问题时，应能自动使缓存失效并进行重建。
- 3.3 风险考量 (Risk Considerations):
  - 3.3.1 SQLite并发访问: 设计时需确保对SQLite数据库的并发访问是安全的。
  - 3.3.2 持久化缓存膨胀: 长期设计需考虑缓存文件的管理策略。
  - 3.3.3 (新增) 功能复杂度: 新增的关联键检查模式将增加前后端逻辑的复杂度，设计时需注重模块化和代码清晰度。
  - 3.3.4 (新增) 数据一致性: 必须设计一种机制，确保缓存的更新与验证模式的切换之间的数据状态是同步和一致的。
- 3.4 (新增) 可用性 (Usability):
  - 3.4.1 清晰引导: 由于引入了多种验证模式，UI设计必须清晰、无歧义。应通过合理的布局、分组和提示性文本，引导用户理解不同模式的用途和区别，降低学习成本。
  - 3.4.2 (新增) 界面风格: 整体界面设计应遵循扁平化、现代感的设计原则。UI元素应简洁，避免不必要的装饰，注重信息层级和操作的直观性。
  - 3.4.3 (新增) 会话级状态保持: 应用应支持会话级配置状态保持，使用localStorage保存用户配置，避免重复配置操作。
  - 3.4.4 (新增) 配置模板功能: 提供预设的常用验证规则模板，支持一键应用和自定义模板管理。
  - 3.4.5 (新增) 增强验证报告导出: 支持多种格式（JSON、CSV、PDF）的验证报告导出功能。

4. 用户故事与验收标准

用户故事1: 首次加载与分层缓存构建
> 作为一名用户，当我首次选择一个大文件时，我希望应用能自动将其预处理并以持久化方式缓存到本地，以便我后续基于此文件的所有操作都变得飞快。

验收标准 (Acceptance Criteria):
- AC 1.1 (后端): 必须有能力将文件数据处理并存入SQLite（持久化数据缓存）。
- AC 1.2 (后端): `start_validation` 命令在执行前，必须检查并构建/加载所需文件的持久化数据缓存和内存缓存。
- AC 1.3 (前端): 在进行任何耗时的预处理或缓存构建时，UI必须有明确的加载提示。

用户故事2: 缓存的智能管理与复用
> 作为一名用户，我不关心缓存的技术细节。我希望当我更换文件或修改规则时，应用能足够智能地最大化复用已有成果，只更新必要的部分。

验收标准 (Acceptance Criteria):
- AC 2.1 (后端 - 缓存失效): 在使用持久化数据缓存前，系统必须通过检查源文件的元数据（如修改时间、大小）来验证其有效性。
- AC 2.2 (后端 - 会话管理): 当用户在UI上为文件A或文件B成功选择了一个新文件后，后端必须立即清理与该文件槽位（A或B）关联的所有缓存（包括持久化缓存和内存缓存）。
- AC 2.3 (后端 - 增量更新占位): （可选，本次迭代不实现）。
- AC 2.4 (新增 - 智能分层缓存管理): 系统必须实现一个支持独立管理的分层缓存（持久化缓存+内存缓存）。当用户仅更换文件A时，系统必须只清除/重建与文件A相关的缓存。此时，文件B的持久化缓存和内存缓存都必须被完整保留和复用，反之亦然。

用户故事3: (最终版) 新增关联键一致性检查模式
> 作为一名用户，我希望能切换到一个新的"关联键一致性检查"模式。在此模式下，我可以进一步选择是想看"交集"（在B中成功匹配的A记录）还是"差异"（在B中找不到匹配的A记录）。

验收标准 (Acceptance Criteria):
- AC 3.1 (DTO): `ProjectConfig` DTO 必须包含一个能够描述这种分层模式的字段。例如，一个 `ValidationMode` 枚举，其定义类似：`enum ValidationMode { RuleBased, KeyConsistency { sub_mode: KeyConsistencySubMode } }`，其中 `KeyConsistencySubMode` 包含 `Intersection` 和 `Difference` 两个变体。
- AC 3.2 (前端): UI 必须提供一个顶层控件（如单选按钮组）用于在"规则验证"和"关联键一致性检查"之间切换。当且仅当"关联键一致性检查"被选中时，才显示第二个子控件，用于在"交集"和"差异"之间选择。
- AC 3.3 (后端 - 交集实现): 当模式为 KeyConsistency { sub_mode: Intersection }
  时，后端逻辑应返回所有在文件B中能找到对应关联键的文件A的数据行和B的数据行。
- AC 3.4 (后端 - 差异实现 - 已修正): 当模式为 `KeyConsistency { sub_mode: Difference }` 时，后端逻辑应**只返回**在文件B中找不到对应关联键的**文件A的数据行**。报告中不应包含文件B的任何数据。

用户故事4: 替代功能方案 - 增强用户体验
> 作为一名用户，我希望应用提供更智能的配置管理和报告功能，避免复杂的保存/加载操作，同时获得更好的使用体验。

验收标准 (Acceptance Criteria):
- AC 4.1 (会话级状态保持): 应用应自动保存用户当前的配置状态到localStorage，在浏览器会话重启后能够自动恢复上次的配置。
- AC 4.2 (配置模板功能): UI应提供预设的验证规则模板选择器，支持一键应用常用验证规则组合，并允许用户保存自定义模板。
- AC 4.3 (增强验证报告导出): 验证结果应支持多种格式导出（JSON、CSV、PDF），导出功能应包含格式选择和自定义配置选项。
